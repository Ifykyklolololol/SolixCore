-- AdvancedMoverV2.lua
-- Robust NPC mover using Roblox Pathfinding + safer MoveTo handling
-- Returns: true on success; false, reason on failure

local AdvancedMover = {}
AdvancedMover.__index = AdvancedMover

local PathfindingService = game:GetService("PathfindingService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local DEFAULTS = {
    AgentRadius = 2,
    AgentHeight = 5,
    AgentCanJump = true,
    AgentJumpHeight = 7,
    MaxRetries = 4,               -- number of times to re-compute path
    RepathInterval = 0.9,         -- seconds between attempts
    StuckTime = 2.0,              -- time to consider humanoid stuck
    StuckDistance = 0.35,         -- movement threshold (studs)
    WaypointTolerance = 1.5,      -- how close to a waypoint counts
    WalkSpeed = nil,              -- optional override while moving
    RunSpeed = nil,
    AutoJump = true,
    ObstacleCheckDistance = 3.2,  -- forward raycast distance
    ObstacleIgnoreHeight = 0.3,   -- ignore hits very close to root Y (floor seams)
    MaxVaultHeight = 2.0,
    VaultForwardOffset = 1.1,
    MoveToFalseDelay = 1.2,       -- wait before trusting a MoveToFinished false
    Debug = false,
}

-- Utility debug print
local function dprint(self, ...)
    if self.options.Debug then
        print("[AdvancedMoverV2]", ...)
    end
end

-- Create a Path object with configured agent params
local function createPath(self)
    return PathfindingService:CreatePath({
        AgentRadius = self.options.AgentRadius,
        AgentHeight = self.options.AgentHeight,
        AgentCanJump = self.options.AgentCanJump,
    })
end

-- Raycast wrapper
local function raycast(origin, direction, params)
    return Workspace:Raycast(origin, direction, params)
end

-- Probe obstacle in front of rootPart along forwardDirection (Vector3)
local function probeObstacle(self, rootPart, forwardDirection, ignoreInstances)
    if not forwardDirection or forwardDirection.Magnitude < 0.01 then return nil end
    local origin = rootPart.Position + Vector3.new(0, math.clamp(self.options.AgentHeight * 0.35, 0.5, self.options.AgentHeight), 0)
    local dir = forwardDirection.Unit * self.options.ObstacleCheckDistance
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {rootPart.Parent}
    if ignoreInstances then
        for _, inst in ipairs(ignoreInstances) do
            table.insert(rayParams.FilterDescendantsInstances, inst)
        end
    end

    local res = raycast(origin, dir, rayParams)
    if not res then return nil end

    local hitPos = res.Position
    local relativeHeight = hitPos.Y - rootPart.Position.Y
    local dist = (hitPos - origin).Magnitude

    -- ignore tiny floor seams or hits very close to the root's Y (to avoid re-pathing on ground geometry)
    if math.abs(relativeHeight) <= self.options.ObstacleIgnoreHeight and dist > (self.options.ObstacleCheckDistance * 0.9) == false then
        -- allow near-ground hits if they're actually close and likely floor
        -- fall through and return only if it's meaningful
    end

    return {
        instance = res.Instance,
        position = hitPos,
        normal = res.Normal,
        relativeHeight = relativeHeight,
        distance = dist,
    }
end

-- Try to vault small obstacles by issuing a jump and MoveTo beyond it
local function attemptVault(self, humanoid, rootPart, obstacleInfo, beyondPoint)
    if not self.options.AutoJump then return false end
    if not obstacleInfo then return false end

    if obstacleInfo.relativeHeight <= self.options.MaxVaultHeight and obstacleInfo.distance <= (self.options.ObstacleCheckDistance * 0.95) then
        dprint(self, "Attempt vault: height=", obstacleInfo.relativeHeight, "dist=", obstacleInfo.distance)
        humanoid.Jump = true
        -- small forward push to get over
        local forward = (beyondPoint and (beyondPoint - rootPart.Position) or rootPart.CFrame.LookVector)
        local pushTo = rootPart.Position + forward.Unit * (self.options.VaultForwardOffset + 0.4)
        humanoid:MoveTo(pushTo)
        return true
    end
    return false
end

-- Safe path compute wrapper
local function computePath(self, startPos, endPos)
    local path = createPath(self)
    local ok, err = pcall(function()
        path:ComputeAsync(startPos, endPos)
    end)
    if not ok then
        return nil, ("ComputeAsync error: %s"):format(tostring(err))
    end
    if path.Status ~= Enum.PathStatus.Success then
        return nil, ("Path status: %s"):format(tostring(path.Status))
    end
    return path:GetWaypoints()
end

-- Create instance
function AdvancedMover.new(opts)
    local self = setmetatable({}, AdvancedMover)
    self.options = {}
    for k, v in pairs(DEFAULTS) do self.options[k] = v end
    if opts then for k, v in pairs(opts) do self.options[k] = v end end

    -- state
    self._isMoving = false
    self._cancelToken = false
    self._moveId = 0
    return self
end

function AdvancedMover:IsMoving()
    return self._isMoving
end

function AdvancedMover:Cancel()
    self._cancelToken = true
    self._moveId = self._moveId + 1
end

-- Internal helper to cleanup connections
local function safeDisconnect(conn)
    if conn and conn.Disconnect then
        conn:Disconnect()
    elseif conn and conn.disconnect then
        conn:disconnect()
    end
end

-- Core MoveToAsync
-- humanoid: Humanoid
-- rootPart: BasePart (HumanoidRootPart)
-- destination: Vector3
-- options: table override
-- returns true or false, reason
function AdvancedMover:MoveToAsync(humanoid, rootPart, destination, options)
    assert(humanoid and humanoid:IsA("Humanoid"), "AdvancedMoverV2.MoveToAsync requires a Humanoid")
    assert(rootPart and rootPart:IsA("BasePart"), "AdvancedMoverV2.MoveToAsync requires a rootPart (HumanoidRootPart)")
    assert(typeof(destination) == "Vector3", "destination must be a Vector3")

    -- merge options
    local localOptions = {}
    for k, v in pairs(self.options) do localOptions[k] = v end
    if options then for k, v in pairs(options) do localOptions[k] = v end end

    -- set moving state & cancellation token
    self._isMoving = true
    self._cancelToken = false
    self._moveId = self._moveId + 1
    local myMoveId = self._moveId

    local prevWalkSpeed
    if localOptions.WalkSpeed then
        prevWalkSpeed = humanoid.WalkSpeed
        humanoid.WalkSpeed = localOptions.WalkSpeed
    end

    local retries = 0
    local startPos = rootPart.Position
    local destPos = destination
    local failReason

    -- helper to detect cancellation coherently (supports other Cancel calls)
    local function canceled()
        return self._cancelToken or (myMoveId ~= self._moveId)
    end

    -- small helper to wait while checking cancellation
    local function waitHeartbeat(timeout)
        timeout = timeout or 0.1
        local start = tick()
        while true do
            if canceled() then return false end
            RunService.Heartbeat:Wait()
            if (tick() - start) >= timeout then return true end
        end
    end

    -- attempt loop
    while retries <= localOptions.MaxRetries do
        if canceled() then
            failReason = "cancelled"
            break
        end

        dprint(self, ("Path compute attempt %d (retries=%d) from %s to %s"):format(retries + 1, retries, tostring(rootPart.Position), tostring(destPos)))
        local waypoints, err = computePath(self, rootPart.Position, destPos)
        if not waypoints then
            dprint(self, "Compute failed:", err)
            retries = retries + 1
            if retries > localOptions.MaxRetries then
                failReason = ("Exceeded max retries (compute failed): %s"):format(err)
                break
            end
            local waited = 0
            while waited < localOptions.RepathInterval do
                if canceled() then break end
                RunService.Heartbeat:Wait()
                waited = waited + RunService.Heartbeat:Wait and 0 or 0 -- no-op to keep pattern (we already waited)
                -- We'll just use a small sleep by Heartbeat yields; primary loop iteration maintains responsiveness
                break
            end
            continue
        end

        -- follow waypoints
        local wpIndex = 1
        local total = #waypoints
        dprint(self, "Waypoints count:", total)

        -- path-level stuck detection
        local lastPos = rootPart.Position
        local lastPosTime = tick()
        local pathStuckStart = nil

        while wpIndex <= total do
            if canceled() then break end

            local wp = waypoints[wpIndex]
            local nextWp = waypoints[wpIndex + 1]
            local targetPos = wp.Position

            -- if waypoint asks for jump, do it
            if wp.Action == Enum.PathWaypointAction.Jump and localOptions.AutoJump then
                humanoid.Jump = true
                dprint(self, "Waypoint action: JUMP at", targetPos)
            end

            -- use next waypoint as target when jumping/for smoothing
            if nextWp and wp.Action == Enum.PathWaypointAction.Jump then
                targetPos = nextWp.Position
            end

            dprint(self, ("Moving to waypoint %d/%d -> %s"):format(wpIndex, total, tostring(targetPos)))
            humanoid:MoveTo(targetPos)

            -- MoveToFinished handling
            local movedFlag = nil
            local moveConn
            moveConn = humanoid.MoveToFinished:Connect(function(reached)
                movedFlag = reached
            end)

            local startWait = tick()
            local doneThisWp = false
            while not doneThisWp do
                if canceled() then break end

                RunService.Heartbeat:Wait()

                -- proximity check
                local dist = (rootPart.Position - targetPos).Magnitude
                if dist <= localOptions.WaypointTolerance then
                    dprint(self, ("Waypoint %d reached by proximity (dist=%.2f)"):format(wpIndex, dist))
                    doneThisWp = true
                    break
                end

                -- conservative interpretation of MoveToFinished false
                if movedFlag == false and (tick() - startWait) >= localOptions.MoveToFalseDelay then
                    local farDist = (rootPart.Position - targetPos).Magnitude
                    if farDist > (localOptions.WaypointTolerance * 4) then
                        dprint(self, "MoveToFinished=false and far -> trigger repath")
                        -- break the waypoint loop and force re-path
                        doneThisWp = false
                        break
                    else
                        -- we're close enough, treat as reached
                        doneThisWp = true
                        break
                    end
                end

                -- normal positive MoveToFinished
                if movedFlag == true then
                    dprint(self, "MoveToFinished true -> waypoint considered reached")
                    doneThisWp = true
                    break
                end

                -- stuck detection by displacement
                if (rootPart.Position - lastPos).Magnitude > localOptions.StuckDistance then
                    lastPos = rootPart.Position
                    lastPosTime = tick()
                    pathStuckStart = nil
                else
                    if (tick() - lastPosTime) >= localOptions.StuckTime then
                        if not pathStuckStart then
                            pathStuckStart = tick()
                            dprint(self, "Potential stuck detected; starting timer")
                        elseif tick() - pathStuckStart >= (localOptions.StuckTime * 1.2) then
                            dprint(self, "Persistent stuck -> trigger repath")
                            doneThisWp = false
                            break
                        end
                    end
                end

                -- probe for obstacles ahead (only when moving toward target)
                local forward = (targetPos - rootPart.Position)
                if forward.Magnitude > 0.2 then
                    local obs = probeObstacle(self, rootPart, forward)
                    if obs and obs.distance <= (localOptions.ObstacleCheckDistance * 0.85) then
                        dprint(self, "Obstacle detected near path:", obs.instance:GetFullName(), "height=", obs.relativeHeight, "dist=", obs.distance)
                        local beyond = (nextWp and nextWp.Position) or (targetPos + forward.Unit * (localOptions.VaultForwardOffset))
                        local vaulted = attemptVault(self, humanoid, rootPart, obs, beyond)
                        if vaulted then
                            -- give vault a short time for movement to start
                            wait(0.12)
                        else
                            dprint(self, "Cannot vault -> repath")
                            doneThisWp = false
                            break
                        end
                    end
                end

                -- safety timeout (per waypoint)
                if tick() - startWait > 12 then
                    dprint(self, "Waypoint wait timed out (12s) -> repath")
                    doneThisWp = false
                    break
                end
            end

            safeDisconnect(moveConn)
            moveConn = nil

            -- check whether cancellation occurred
            if canceled() then break end

            -- if doneThisWp true -> advance; else -> break to recompute path
            if doneThisWp then
                wpIndex = wpIndex + 1
            else
                -- break to recompute a fresh path
                dprint(self, "Breaking waypoint loop to recompute path")
                break
            end

            -- if near final destination, finish
            if (rootPart.Position - destPos).Magnitude <= localOptions.WaypointTolerance then
                dprint(self, "Arrived at destination (close enough).")
                -- restore speed
                if prevWalkSpeed then
                    humanoid.WalkSpeed = prevWalkSpeed
                end
                self._isMoving = false
                return true
            end
        end -- waypoint loop

        if canceled() then
            failReason = "cancelled"
            break
        end

        -- final reached check (in case we left waypoint loop because we reached target)
        if (rootPart.Position - destPos).Magnitude <= localOptions.WaypointTolerance then
            dprint(self, "Arrived at destination after waypoint loop.")
            if prevWalkSpeed then humanoid.WalkSpeed = prevWalkSpeed end
            self._isMoving = false
            return true
        end

        -- if here, we need to recompute path (increase retries)
        retries = retries + 1
        if retries > localOptions.MaxRetries then
            failReason = "Exceeded max retry attempts while pathing"
            break
        end

        dprint(self, ("Recomputing path... attempt %d/%d"):format(retries + 1, localOptions.MaxRetries + 1))
        local waited = 0
        local interval = localOptions.RepathInterval
        while waited < interval do
            if canceled() then break end
            RunService.Heartbeat:Wait()
            waited = waited + RunService.Heartbeat:Wait and 0 or 0 -- noop (we are using Heartbeat wait for responsiveness)
            break -- short yield; primary loop will iterate promptly
        end
    end -- retries loop

    -- restore speed
    if prevWalkSpeed then
        humanoid.WalkSpeed = prevWalkSpeed
    end

    self._isMoving = false
    return false, failReason or "unknown failure"
end

return AdvancedMover
