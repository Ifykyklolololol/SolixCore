print("ver 1.3")
-- A smooth, modern UI library for displaying detection prompts

local DetectionUI = {}
DetectionUI.__index = DetectionUI

local TweenService = game:GetService("TweenService")

-- UI Configuration
local CONFIG = {
	BackgroundColor = Color3.fromRGB(25, 25, 30),
	BackgroundColor2 = Color3.fromRGB(35, 35, 40),
	BorderColor = Color3.fromRGB(70, 70, 80),
	TextColor = Color3.fromRGB(240, 240, 245),
	TextColorSecondary = Color3.fromRGB(200, 200, 210),
	AccentColor = Color3.fromRGB(52, 211, 153), -- Modern green for Run Anyway button
	CloseButtonColor = Color3.fromRGB(239, 68, 68), -- Modern red for X button
	ShadowColor = Color3.fromRGB(0, 0, 0),
	TransitionTime = 0.35,
	EasingStyle = Enum.EasingStyle.Quad,
	EasingDirection = Enum.EasingDirection.Out,
	ShadowOffset = 8
}

function DetectionUI.new()
	local self = setmetatable({}, DetectionUI)
	
	self.gui = nil
	self.mainFrame = nil
	self.result = nil
	self.isVisible = false
	
	return self
end

function DetectionUI:CreateUI()
	-- Create ScreenGui
	self.gui = Instance.new("ScreenGui")
	self.gui.Name = "DetectionUI"
	self.gui.ResetOnSpawn = false
	self.gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	self.gui.Parent = game:GetService("CoreGui")
	
	-- Add shadow effect (behind main frame) - responsive
	local shadow = Instance.new("Frame")
	shadow.Name = "Shadow"
	shadow.Size = UDim2.new(0, 500, 0, 200) -- Will be updated
	shadow.Position = UDim2.new(0.5, CONFIG.ShadowOffset / 2, 0.5, CONFIG.ShadowOffset / 2)
	shadow.AnchorPoint = Vector2.new(0.5, 0.5)
	shadow.BackgroundColor3 = CONFIG.ShadowColor
	shadow.BackgroundTransparency = 0.8
	shadow.BorderSizePixel = 0
	shadow.ZIndex = 1
	shadow.Parent = self.gui
	
	-- Make shadow responsive with constraints
	local shadowConstraint = Instance.new("UISizeConstraint")
	shadowConstraint.MaxSize = Vector2.new(500, math.huge)
	shadowConstraint.MinSize = Vector2.new(300, 180)
	shadowConstraint.Parent = shadow
	
	local shadowCorner = Instance.new("UICorner")
	shadowCorner.CornerRadius = UDim.new(0, 16)
	shadowCorner.Parent = shadow
	
	-- Create main container frame (responsive with scale)
	self.mainFrame = Instance.new("Frame")
	self.mainFrame.Name = "MainFrame"
	self.mainFrame.Size = UDim2.new(0.85, 0, 0, 0) -- 85% of screen width, height auto
	self.mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	self.mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	self.mainFrame.BackgroundColor3 = CONFIG.BackgroundColor
	self.mainFrame.BorderSizePixel = 0
	self.mainFrame.ZIndex = 2
	self.mainFrame.AutomaticSize = Enum.AutomaticSize.Y
	self.mainFrame.Parent = self.gui
	
	-- Add size constraints for responsive design
	local sizeConstraint = Instance.new("UISizeConstraint")
	sizeConstraint.MaxSize = Vector2.new(500, math.huge)
	sizeConstraint.MinSize = Vector2.new(300, 180)
	sizeConstraint.Parent = self.mainFrame
	
	-- Add corner radius (responsive)
	local corner = Instance.new("UICorner")
	corner.CornerRadius = UDim.new(0, 16)
	corner.Parent = self.mainFrame
	
	-- Add subtle border
	local border = Instance.new("UIStroke")
	border.Color = CONFIG.BorderColor
	border.Thickness = 1
	border.Transparency = 0.5
	border.Parent = self.mainFrame
	
	-- Create top bar with title and close button (responsive)
	local topBar = Instance.new("Frame")
	topBar.Name = "TopBar"
	topBar.Size = UDim2.new(1, -30, 0, 0)
	topBar.Position = UDim2.new(0, 15, 0, 15)
	topBar.BackgroundTransparency = 1
	topBar.AutomaticSize = Enum.AutomaticSize.Y
	topBar.Parent = self.mainFrame
	
	-- Title (responsive with text wrapping)
	local title = Instance.new("TextLabel")
	title.Name = "Title"
	title.Size = UDim2.new(1, -50, 0, 0)
	title.Position = UDim2.new(0, 0, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "Game files changed! There is a risk of detection. Press proceed if you'd like to run the script anyway."
	title.TextColor3 = CONFIG.TextColor
	title.TextSize = 16 -- Will scale with TextScaled if needed
	title.Font = Enum.Font.GothamBold
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.TextYAlignment = Enum.TextYAlignment.Top
	title.TextWrapped = true
	title.AutomaticSize = Enum.AutomaticSize.Y
	title.LineHeight = 1.3
	title.Parent = topBar
	
	-- Close button (X) - responsive size, touch-friendly (min 36px for mobile)
	local closeButton = Instance.new("TextButton")
	closeButton.Name = "CloseButton"
	closeButton.Size = UDim2.new(0, 0, 0, 0) -- Will be set with constraints
	closeButton.Position = UDim2.new(1, -45, 0, 0)
	closeButton.BackgroundColor3 = CONFIG.CloseButtonColor
	closeButton.Text = "Ã—"
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.TextSize = 20
	closeButton.Font = Enum.Font.GothamBold
	closeButton.BorderSizePixel = 0
	closeButton.Parent = topBar
	
	-- Make close button responsive with min size for touch
	local closeButtonConstraint = Instance.new("UISizeConstraint")
	closeButtonConstraint.MinSize = Vector2.new(36, 36)
	closeButtonConstraint.MaxSize = Vector2.new(40, 40)
	closeButtonConstraint.Parent = closeButton
	
	-- Set close button size relative to parent
	closeButton.Size = UDim2.new(0, 36, 0, 36)
	
	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 8)
	closeCorner.Parent = closeButton
	
	-- Divider line
	local divider = Instance.new("Frame")
	divider.Name = "Divider"
	divider.Size = UDim2.new(1, 0, 0, 1)
	divider.Position = UDim2.new(0, 0, 1, 10)
	divider.BackgroundColor3 = CONFIG.BorderColor
	divider.BackgroundTransparency = 0.7
	divider.BorderSizePixel = 0
	divider.Parent = topBar
	
	-- Close button hover effect (responsive)
	closeButton.MouseEnter:Connect(function()
		local currentSize = closeButton.AbsoluteSize.X
		local hoverSize = currentSize + 2
		local tween = TweenService:Create(
			closeButton,
			TweenInfo.new(0.15, CONFIG.EasingStyle, CONFIG.EasingDirection),
			{BackgroundTransparency = 0.15, Size = UDim2.new(0, hoverSize, 0, hoverSize)}
		)
		tween:Play()
	end)
	
	closeButton.MouseLeave:Connect(function()
		local tween = TweenService:Create(
			closeButton,
			TweenInfo.new(0.15, CONFIG.EasingStyle, CONFIG.EasingDirection),
			{BackgroundTransparency = 0, Size = UDim2.new(0, 36, 0, 36)}
		)
		tween:Play()
	end)
	
	-- Close button click
	closeButton.MouseButton1Click:Connect(function()
		self.result = false
		self:Hide()
	end)
	
	-- Bottom bar with Run Anyway button (responsive)
	local bottomBar = Instance.new("Frame")
	bottomBar.Name = "BottomBar"
	bottomBar.Size = UDim2.new(1, -30, 0, 60)
	bottomBar.Position = UDim2.new(0, 15, 1, -65)
	bottomBar.BackgroundTransparency = 1
	bottomBar.Parent = self.mainFrame
	
	-- Run Anyway button (responsive, touch-friendly - min 48px height for mobile)
	local runButton = Instance.new("TextButton")
	runButton.Name = "RunButton"
	runButton.Size = UDim2.new(0, 220, 0, 48) -- Base size, will be constrained
	runButton.Position = UDim2.new(0.5, 0, 0, 0)
	runButton.AnchorPoint = Vector2.new(0.5, 0)
	runButton.BackgroundColor3 = CONFIG.AccentColor
	runButton.Text = "Run Anyway"
	runButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	runButton.TextSize = 17
	runButton.Font = Enum.Font.GothamBold
	runButton.BorderSizePixel = 0
	runButton.Parent = bottomBar
	
	-- Make button responsive with constraints
	local buttonConstraint = Instance.new("UISizeConstraint")
	buttonConstraint.MinSize = Vector2.new(200, 48) -- Touch-friendly minimum
	buttonConstraint.MaxSize = Vector2.new(280, 52)
	buttonConstraint.Parent = runButton
	
	local runCorner = Instance.new("UICorner")
	runCorner.CornerRadius = UDim.new(0, 10)
	runCorner.Parent = runButton
	
	-- Add button glow effect
	local buttonGlow = Instance.new("UIStroke")
	buttonGlow.Color = CONFIG.AccentColor
	buttonGlow.Thickness = 2
	buttonGlow.Transparency = 0.7
	buttonGlow.Parent = runButton
	
	-- Run button hover effect (responsive)
	runButton.MouseEnter:Connect(function()
		local currentWidth = runButton.AbsoluteSize.X
		local currentHeight = runButton.AbsoluteSize.Y
		local tween1 = TweenService:Create(
			runButton,
			TweenInfo.new(0.2, CONFIG.EasingStyle, CONFIG.EasingDirection),
			{BackgroundTransparency = 0.05, Size = UDim2.new(0, currentWidth + 10, 0, currentHeight + 2)}
		)
		local tween2 = TweenService:Create(
			buttonGlow,
			TweenInfo.new(0.2, CONFIG.EasingStyle, CONFIG.EasingDirection),
			{Transparency = 0.3, Thickness = 3}
		)
		tween1:Play()
		tween2:Play()
	end)
	
	runButton.MouseLeave:Connect(function()
		local tween1 = TweenService:Create(
			runButton,
			TweenInfo.new(0.2, CONFIG.EasingStyle, CONFIG.EasingDirection),
			{BackgroundTransparency = 0, Size = UDim2.new(0, 220, 0, 48)}
		)
		local tween2 = TweenService:Create(
			buttonGlow,
			TweenInfo.new(0.2, CONFIG.EasingStyle, CONFIG.EasingDirection),
			{Transparency = 0.7, Thickness = 2}
		)
		tween1:Play()
		tween2:Play()
	end)
	
	-- Run button click
	runButton.MouseButton1Click:Connect(function()
		self.result = true
		self:Hide()
	end)
	
	-- Store shadow reference
	self.shadow = shadow
	
	-- Connection to update shadow size when main frame size changes
	local function updateShadowSize()
		if self.mainFrame and self.shadow then
			local mainSize = self.mainFrame.AbsoluteSize
			self.shadow.Size = UDim2.new(0, mainSize.X + CONFIG.ShadowOffset, 0, mainSize.Y + CONFIG.ShadowOffset)
		end
	end
	
	-- Update shadow when main frame size changes
	self.mainFrame:GetPropertyChangedSignal("AbsoluteSize"):Connect(updateShadowSize)
	
	-- Initially hide the UI
	self.mainFrame.Size = UDim2.new(0, 0, 0, 0)
	self.mainFrame.Visible = false
	shadow.Size = UDim2.new(0, 0, 0, 0)
	shadow.Visible = false
end


function DetectionUI:Show()
	if not self.gui then
		self:CreateUI()
	end
	
	self.isVisible = true
	self.result = nil
	
	-- Show the UI
	if self.shadow then
		self.shadow.Visible = true
	end
	self.mainFrame.Visible = true
	
	-- Temporarily set size to calculate final dimensions
	self.mainFrame.Size = UDim2.new(0.85, 0, 0, 0)
	self.mainFrame.AutomaticSize = Enum.AutomaticSize.Y
	
	-- Wait for layout to calculate
	task.wait(0.1)
	
	-- Get final sizes
	local finalMainSize = self.mainFrame.AbsoluteSize
	local finalShadowSize = Vector2.new(finalMainSize.X + CONFIG.ShadowOffset, finalMainSize.Y + CONFIG.ShadowOffset)
	
	-- Reset to 0 for animation
	self.mainFrame.Size = UDim2.new(0, 0, 0, 0)
	
	-- Animate in - shadow first, then main frame
	if self.shadow then
		local shadowTween = TweenService:Create(
			self.shadow,
			TweenInfo.new(CONFIG.TransitionTime, CONFIG.EasingStyle, CONFIG.EasingDirection),
			{
				Size = UDim2.new(0, finalShadowSize.X, 0, finalShadowSize.Y),
				Position = UDim2.new(0.5, CONFIG.ShadowOffset / 2, 0.5, CONFIG.ShadowOffset / 2)
			}
		)
		shadowTween:Play()
	end
	
	-- Animate main frame to final size
	local showTween = TweenService:Create(
		self.mainFrame,
		TweenInfo.new(CONFIG.TransitionTime, CONFIG.EasingStyle, CONFIG.EasingDirection),
		{Size = UDim2.new(0, finalMainSize.X, 0, finalMainSize.Y)}
	)
	showTween:Play()
	showTween.Completed:Wait()
	
	-- Re-enable automatic size for responsive behavior
	self.mainFrame.Size = UDim2.new(0.85, 0, 0, 0)
	self.mainFrame.AutomaticSize = Enum.AutomaticSize.Y
end

function DetectionUI:Hide()
	if not self.isVisible then
		return
	end
	
	self.isVisible = false
	
	-- Animate out
	local hideTween = TweenService:Create(
		self.mainFrame,
		TweenInfo.new(CONFIG.TransitionTime, CONFIG.EasingStyle, CONFIG.EasingDirection),
		{Size = UDim2.new(0, 0, 0, 0)}
	)
	
	if self.shadow then
		local shadowTween = TweenService:Create(
			self.shadow,
			TweenInfo.new(CONFIG.TransitionTime, CONFIG.EasingStyle, CONFIG.EasingDirection),
			{
				Size = UDim2.new(0, 0, 0, 0),
				Position = UDim2.new(0.5, 0, 0.5, 0)
			}
		)
		shadowTween:Play()
	end
	
	hideTween:Play()
	hideTween.Completed:Wait()
	
	-- Clean up
	if self.gui then
		self.gui:Destroy()
		self.gui = nil
		self.mainFrame = nil
		self.shadow = nil
	end
end

function DetectionUI:Prompt()
	-- Create UI if it doesn't exist
	if not self.gui then
		self:CreateUI()
	end
	
	-- Show UI
	self:Show()
	
	-- Wait for user response
	while self.result == nil do
		task.wait(0.1)
	end
	
	local result = self.result
	return result
end

-- Create global API
local guiAPI = DetectionUI.new()

-- Example usage:
--[[
if scriptChanged then
	if not guiAPI:Prompt() then
		return -- don't load script
	end
end
]]

return guiAPI
